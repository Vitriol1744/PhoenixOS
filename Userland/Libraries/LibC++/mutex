/*
 * Created by vitriol1744 on 07.06.2023.
 * Copyright (c) 2022-2023, Szymon Zemke <Vitriol1744@gmail.com>
 *
 * SPDX-License-Identifier: GPL-3
 */
#pragma once

#include <atomic>
#include <system_error>

#if __STDC_HOSTED__ == 1
    #define _HandleError(error_code, error_message)                            \
        throw std::system_error(error_code, error_messsage);
#else
    #define _HandleError(error_code, error_message) Panic(error_message);
    #include "Common.hpp"
#endif

#include "Arch/Arch.hpp"

namespace Arch
{
    // TODO: Move it somewhere else
#if PH_ARCH == 0x00
    inline void Pause() { __asm__ volatile("pause"); }
#elif PH_ARCH == 0x01
    inline void Pause() { __asm__ volatile("yield"); }
#endif
} // namespace Arch

namespace std
{
    class mutex
    {
      public:
        constexpr mutex() noexcept = default;
        mutex(const mutex&)        = delete;
        mutex& operator=(mutex&)   = delete;

        void   lock()
        {
            auto ticket = _next_ticket.fetch_add(1, std::memory_order_relaxed);
            while (_serving_ticket.load(std::memory_order_acquire) != ticket)
                Arch::Pause();
        }
        bool try_lock()
        {
            if (is_locked()) return false;

            lock();
            return true;
        }
        void unlock()
        {
            if (!is_locked()) return;

            auto current = _serving_ticket.load(std::memory_order_relaxed);
            _serving_ticket.store(current + 1, std::memory_order_release);
        }

      private:
        std::atomic_size_t _next_ticket    = 0;
        std::atomic_size_t _serving_ticket = 0;

        bool               is_locked()
        {
            auto current = _serving_ticket.load(std::memory_order_relaxed);
            auto next    = _next_ticket.load(std::memory_order_relaxed);
            return current != next;
        }
    };

    struct defer_lock_t
    {
        explicit defer_lock_t() = default;
    };
    struct try_to_lock_t
    {
        explicit try_to_lock_t() = default;
    };
    struct adopt_lock_t
    {
        explicit adopt_lock_t() = default;
    };

    inline constexpr defer_lock_t  defer_lock{};
    inline constexpr try_to_lock_t try_to_lock{};
    inline constexpr adopt_lock_t  adopt_lock{};

    template <typename Type>
    class unique_lock
    {
      public:
        using mutex_type = Type;

        unique_lock()
            : _mutex(nullptr)
            , _locked(false)
        {
        }

        unique_lock(unique_lock&& other) noexcept
            : _mutex(nullptr)
            , _locked(false)
        {
            swap(other);
        }

        explicit unique_lock(mutex_type& m)
            : _mutex(addressof(m))
            , _locked(true)
        {
            m.lock();
        }
        unique_lock(mutex_type& m, defer_lock_t t) noexcept
            : _mutex(addressof(m))
            , _locked(false)
        {
        }
        unique_lock(mutex_type& m, try_to_lock_t t)
            : _mutex(addressof(m))
            , _locked(true)
        {
            m.try_lock();
        }
        unique_lock(mutex_type& m, adopt_lock_t t)
            : _mutex(addressof(m))
            , _locked(true)
        {
        }
        //        template <typename Rep, typename Period>
        //        unique_lock(mutex_type&                               m,
        //                    const std::chrono::duration<Rep, Period>&
        //                    timeout_duration);
        //        template <typename Clock, typename Duration>
        //        unique_lock(
        //            mutex_type&                                     m,
        //            const std::chrono::time_point<Clock, Duration>&
        //            timeout_time);
        ~unique_lock()
        {
            if (_locked) _mutex->unlock();
        }

        unique_lock& operator=(unique_lock&& other)
        {
            if (_locked) unlock();

            swap(other);
            return *this;
        }

        void lock()
        {
            if (!_mutex)
                _HandleError(std::errc::operation_not_permitted,
                             "std::unique_lock::lock() - no associated mutex!");
            if (owns_lock())
                _HandleError(
                    std::errc::resource_deadlock_would_occur,
                    "std::unique_lock::lock() - mutex already locked!");
            _mutex->lock();
            _locked = true;
        }

        bool try_lock()
        {
            if (!_mutex)
                _HandleError(
                    std::errc::operation_not_permitted,
                    "std::unique_lock::try_lock() - no associated mutex!");
            if (owns_lock())
                _HandleError(
                    std::errc::resource_deadlock_would_occur,
                    "std::unique_lock::try_lock() - mutex already locked!");

            auto _locked = _mutex->try_lock();
            return _locked;
        }
        //        template <typename Rep, typename Period>
        //        bool try_lock_for(
        //            const std::chrono::duration<Rep, Period>&
        //            timeout_duration);
        //        template <typename Clock, typename Duration>
        //        bool try_lock_until(
        //            const std::chrono::time_point<Clock, Duration>&
        //            timeout_time);
        void unlock()
        {
            if (!_mutex)
                _HandleError(
                    std::errc::operation_not_permitted,
                    "std::unique_lock::unlock() - no associated mutex!");
            if (!owns_lock())
                _HandleError(
                    std::errc::operation_not_permitted,
                    "std::unique_lock::unlock() - mutex already unlocked!");

            _mutex->unlock();
            _locked = false;
        }

        void swap(unique_lock& other) noexcept
        {
            std::swap(_mutex, other._mutex);
            std::swap(_locked, other._locked);
        }

        mutex_type* release() noexcept
        {
            auto ret = _mutex;
            _mutex   = nullptr;
            _locked  = false;

            return ret;
        }

        mutex_type* mutex() const noexcept { return _mutex; }
        bool        owns_lock() const noexcept { return _mutex && _locked; }
        explicit operator bool() const noexcept { return owns_lock(); }

        friend void swap(unique_lock& lhs, unique_lock& rhs) noexcept
        {
            return lhs.swap(rhs);
        }

      private:
        Type* _mutex;
        bool  _locked;
    };

    template <typename Mutex>
    void swap(unique_lock<Mutex>& lhs, unique_lock<Mutex>& rhs) noexcept
    {
        lhs.swap(rhs);
    }

    template <typename L0, typename L1>
    void lock(L0& l0, L1& l1)
    {
        while (true)
        {
            {
                unique_lock<L0> u0(l0);
                if (l1.try_lock())
                {
                    u0.release();
                    break;
                }
            }
            {
                unique_lock<L1> u1(l1);
                if (l0.try_lock())
                {
                    u1.release();
                    break;
                }
            }
        }
    }
} // namespace std
